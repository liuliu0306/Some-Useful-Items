# SDF.py

这是一个用Python编写的同步数据流（Synchronous Data Flow）的计算模型，用来处理数据流的运算和传输。同步数据流模型是一种基于数据依赖的并行计算模型，它由一组节点和边组成，每个节点表示一个操作符，每条边表示一个数据通道。每个节点只有在接收到足够的输入数据时才能被执行，执行后会产生输出数据，并将其发送到下游节点。每条边上可以存储一定数量的数据，称为令牌（token），令牌的数量决定了节点是否可以被执行。同步数据流模型具有确定性、可静态调度和可伸缩性等优点。


## 用户

这个代码的用户是需要处理数据流的程序员或者研究人员，他们可以通过定义不同的节点和操作符，来构建自己的数据流网络，并执行它。

## 具体实现
- 首先，调用`execute()`方法，开始执行模型。这个方法会循环执行以下步骤，直到所有节点都不能被执行为止：
  - 调用`_update_fire()`方法，更新所有节点的激活状态。这个方法会遍历所有节点，并调用`_if_fire`方法来检查它们是否可以被执行，并将结果存储在`if_fire_vec`属性中。`_if_fire`方法会根据节点的名称，在令牌向量中找到所有与之相连的边，并检查每条边上是否有令牌，如果有，就返回True，否则返回False。
  - 遍历所有节点，如果一个节点可以被执行，就调用`_get_data_from_token_vec()`方法，获取它的输入数据，并将其存储在节点的`input_buffer`属性中。这个方法会根据节点的名称，在令牌向量中找到所有与之相连的边，并从每条边上取出一个令牌作为输入数据，并返回这些令牌组成的列表。
  - 遍历所有节点，如果一个节点可以被执行，就调用它的`fire()`方法，执行它的操作符，并将结果存储在节点的`output_buffer`属性中。这个方法会从输入缓冲区中取出所有令牌，并将它们作为一个列表传递给操作符，并将操作符返回的结果存储在输出缓冲区中。
  - 遍历所有节点，如果一个节点可以被执行，就调用`_update_token_vec()`方法，更新它的输出数据，并将其发送到下游节点。这个方法会根据节点的名称，在令牌向量中找到所有与之相连的边，并将输出令牌添加到每条边上。
- 最后，打印出每个节点和边上的令牌情况，并结束模型的执行。

## 示例

下面是一个简单的示例，展示了如何使用这个代码来构建和执行一个同步数据流网络。

```python
# 导入SDF类
from SDF import SDF

hello = SDF('hello')  # 创建一个SDF对象

# 添加节点
hello.add_node('root1', lambda x:None)
hello.add_node('root2', lambda x:None)
hello.add_node('end', lambda x:None)
hello.add_node('A_square', lambda x:x**2)
hello.add_node('B_square',lambda x:x**2)
hello.add_node('C_add',lambda x, y:x+y)

# 添加令牌
hello.add_token('root1', 'A_square', [1,2,3])
hello.add_token('root2', 'B_square', [4,5,6])
hello.add_token('A_square', 'C_add', [])
hello.add_token('B_square', 'C_add', [])
hello.add_token('C_add', 'end', [])

hello.execute()
```

下图是SDF的输出: 

! [SDF输出的示例图片] (./figure/run.png)


## 细节

这个代码主要包含两个类：`SDF`和`Node`。

### SDF类

`SDF`类是同步数据流模型的主要类，它有以下几个属性和方法：

- `name`：模型的名称，字符串类型。
- `nodes`：模型中的节点列表，每个元素是一个`Node`对象。
- `if_fire_vec`：激活向量，是一个记录所有节点激活状态的列表，激活表示可以被执行。
- `token_vec`：令牌向量，是一个记录所有边上令牌情况的列表，每个元素是一个三元组，形式为[起始节点，终止节点，令牌]。这个向量在每次令牌更新时都会被修改。
- `add_node(name, operator)`：添加一个节点到模型中，参数为节点的名称（字符串类型）和操作符（函数类型）。操作符是一个接受一个列表作为输入，并返回一个任意类型作为输出的函数。
- `add_token(edge_in, edge_out, data)`：添加一个令牌到模型中，参数为边的起始节点（字符串类型），终止节点（字符串类型）和数据（列表类型）。数据是一个表示边上初始令牌数量和值的列表。
- `_if_fire(current_node)`：检查一个节点是否可以被执行，参数为节点的名称（字符串类型），返回值为布尔类型。一个节点可以被执行的条件是它接收到了所有上游节点发送的令牌。
- `_update_fire()`：更新所有节点的激活状态。这个方法会遍历所有节点，并调用`_if_fire`方法来检查它们是否可以被执行，并将结果存储在`if_fire_vec`属性中。
- `_get_data_from_token_vec(node)`：从令牌向量中获取一个节点的输入数据，参数为一个`Node`对象，返回值为一个列表。这个方法会根据节点的名称，在令牌向量中找到所有与之相连的边，并从每条边上取出一个令牌作为输入数据，并返回这些令牌组成的列表。
- `_update_token_vec(node, token)`：更新令牌向量中一个节点的输出数据，参数为一个`Node`对象和一个令牌（任意类型）。这个方法会根据节点的名称，在令牌向量中找到所有与之相连的边，并将输出令牌添加到每条边上。
- `execute()`：执行模型，核心方法。这个方法会循环执行以下步骤，直到所有节点都不能被执行为止：
  - 调用`_update_fire()`方法，更新所有节点的激活状态。
  - 遍历所有节点，如果一个节点可以被执行，就调用`_get_data_from_token_vec()`方法，获取它的输入数据，并将其存储在节点的`input_buffer`属性中。
  - 遍历所有节点，如果一个节点可以被执行，就调用它的`fire()`方法，执行它的操作符，并将结果存储在节点的`output_buffer`属性中。
  - 遍历所有节点，如果一个节点可以被执行，就调用`_update_token_vec()`方法，更新它的输出数据，并将其发送到下游节点。

### Node类

`Node`类是模型中的基本单元，它有以下几个属性和方法：

- `name`：节点的名称，字符串类型。
- `operator`：节点的操作符，函数类型。
- `input_buffer`：节点的输入缓冲区，列表类型。这个属性用来存储从上游节点接收到的令牌。
- `output_buffer`：节点的输出缓冲区，列表类型。这个属性用来存储执行操作符后产生的令牌。
- `fire()`：执行节点的操作符，并更新输入缓冲区和输出缓冲区。这个方法会从输入缓冲区中取出所有令牌，并将它们作为一个列表传递给操作符，并将操作符返回的结果存储在输出缓冲区中。

